<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Reviews</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <script src="global-nav.js"></script>
  
    <main class="wrap" aria-labelledby="title">
        <section class="card">
            <header class="section-head">
                <div>
                    <h1 id="title">Mason Reviews</h1>
                    <div class="rating-summary">
                        <div class="avg" id="avgRating">0.0</div>
                        <div id="avgStars" class="stars" aria-hidden="true">â˜†â˜†â˜†â˜†â˜†</div>
                        <div class="meta" id="count">(0 reviews)</div>
                    </div>
                </div>
                <div class="muted">
                    Share feedback â€” it helps improve masons drive.
                </div>
            </header>
        </section>

        <div id="reviewsDebug" style="max-width:900px;margin:8px auto 0;color:#b91c1c;font-size:0.95rem;display:none"></div>

        <div id="adminControls" style="max-width:900px;margin:8px auto;display:flex;gap:8px;justify-content:flex-end;align-items:center">
            <div id="adminStatus" style="color:var(--muted);font-size:0.95rem"></div>
            <button id="adminLoginBtn" style="background:#111827;color:#fff;padding:8px 10px;border-radius:8px;border:0;cursor:pointer">Admin Sign In</button>
        </div>

        

        <section aria-label="submit review" style="margin-top:18px">
            <div style="text-align:right;color:var(--muted);font-size:0.9rem">
                
            </div>
        </header>

        <section aria-label="submit review" class="card section">
            <form id="reviewForm" class="form">
                <div class="row stretch">
                    <input id="name" name="name" type="text" placeholder="Your name" required />
                    <select id="rating" name="rating" required>
                        <option value="">Rating</option>
                        <option value="5">5 â€” Excellent</option>
                        <option value="4.5">4.5 â€” Very Good</option>
                        <option value="4">4 â€” Good</option>
                        <option value="3.5">3.5 â€” Above Average</option>
                        <option value="3">3 â€” Okay</option>
                        <option value="2.5">2.5 â€” Below Average</option>
                        <option value="2">2 â€” Poor</option>
                        <option value="1.5">1.5 â€” Very Poor</option>
                        <option value="1">1 â€” Terrible</option>
                        <option value="0.5">0.5 â€” Abysmal</option>
                        <option value="0">0 â€” No Stars</option>
                    </select>
                </div>
                <textarea id="comment" name="comment" placeholder="Write your review..." required></textarea>
                <div class="row" style="justify-content:flex-end">
                    <button type="submit">Submit Review</button>
                </div>
            </form>
        </section>

        <section id="reviewsSection" aria-label="reviews list" class="card section">
            <div class="reviews list" id="reviewsList">
                <div class="empty">No reviews yet. Be the first to leave feedback.</div>
            </div>
        </section>
    </main>

    <!-- Supabase JS (UMD build) -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js/dist/umd/supabase.min.js"></script>

    <script src="chatuser.js"></script>

    <script>
        // Replace with your Supabase project values
        const SUPABASE_URL = 'https://hyehyfbnskiybdspkbxe.supabase.co';
        const SUPABASE_ANON_KEY = 'sb_publishable_Spz2O3ITj_9Q7cT84pKG6w_2h4yOFyu';

        const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Detect whether optional tables exist (review_replies, review_votes) and owner column
        let reviewsExtraTablesAvailable = { replies: false, votes: false };
        let ownerColumnExists = false;
        async function detectExtraTables() {
            try {
                // try lightweight selects to see if tables exist
                const r1 = await sb.from('review_replies').select('id').limit(1);
                reviewsExtraTablesAvailable.replies = !r1.error;
            } catch (e) { reviewsExtraTablesAvailable.replies = false; }
            try {
                const r2 = await sb.from('review_votes').select('id').limit(1);
                reviewsExtraTablesAvailable.votes = !r2.error;
            } catch (e) { reviewsExtraTablesAvailable.votes = false; }
            // If any missing, show a short instruction
            if (!reviewsExtraTablesAvailable.replies || !reviewsExtraTablesAvailable.votes) {
                const dbg = document.getElementById('reviewsDebug');
                if (dbg) {
                    dbg.style.display = 'block';
                    dbg.innerHTML = 'Some optional review features are not available because database tables are missing. Run the SQL migration <code>add_review_replies_and_votes.sql</code> in Supabase to enable replies & voting.';
                }
            }
        }
        detectExtraTables();
        // detect owner column on reviews (some installs don't have it)
        async function detectOwnerColumn() {
            try {
                const probe = await sb.from('reviews').select('owner').limit(1);
                ownerColumnExists = !probe.error;
            } catch (e) { ownerColumnExists = false; }
            // update debug instruction
            if (!ownerColumnExists) {
                const dbg = document.getElementById('reviewsDebug');
                if (dbg) {
                    dbg.style.display = 'block';
                    dbg.innerHTML = dbg.innerHTML + '<div style="margin-top:6px;color:#b91c1c">Note: optional column <code>owner</code> missing â€” run <code>create_admins_and_owner_columns.sql</code> to enable admin badges.</div>';
                }
            }
        }
        detectOwnerColumn();

        // Supabase Auth based admin login
        let currentUser = null;
        let currentUserIsAdmin = false;
        let currentAdminDisplayName = null;
        let adminIdSet = new Set();

        async function refreshAdminSet() {
            try {
                const { data, error } = await sb.from('admins').select('user_id');
                if (error) throw error;
                adminIdSet = new Set((data || []).map(row => row.user_id));
            } catch (e) {
                console.warn('load admins failed', e);
                adminIdSet = new Set();
            }
        }

        async function refreshAuthState() {
            try {
                const { data } = await sb.auth.getUser();
                currentUser = data && data.user ? data.user : null;
            } catch (e) { currentUser = null; }
            if (currentUser) {
                // check admins table
                try {
                    const { data: admin, error } = await sb.from('admins').select('display_name').eq('user_id', currentUser.id).maybeSingle();
                    if (admin && admin.display_name) {
                        currentUserIsAdmin = true;
                        currentAdminDisplayName = admin.display_name;
                    } else {
                        currentUserIsAdmin = false;
                        currentAdminDisplayName = null;
                    }
                } catch (e) { currentUserIsAdmin = false; currentAdminDisplayName = null; }
            } else {
                currentUserIsAdmin = false; currentAdminDisplayName = null;
            }
            updateAdminUI();
        }

        function updateAdminUI() {
            const status = document.getElementById('adminStatus');
            const btn = document.getElementById('adminLoginBtn');
            if (!status || !btn) return;
            if (currentUser) {
                status.textContent = `Signed in as ${currentAdminDisplayName || currentUser.email}`;
                btn.textContent = 'Sign Out';
            } else {
                status.textContent = '';
                btn.textContent = 'Admin Sign In';
            }
        }

        // wire auth state changes
        sb.auth.onAuthStateChange(() => { refreshAuthState(); });
        document.addEventListener('DOMContentLoaded', async () => {
            await refreshAuthState();
            const btn = document.getElementById('adminLoginBtn');
            if (!btn) return;
            btn.addEventListener('click', async () => {
                if (currentUser) {
                    await sb.auth.signOut();
                    await refreshAuthState();
                    return;
                }
                const email = prompt('Admin sign-in email (magic link will be sent):', 'admin@example.com');
                if (!email) return;
                const { error } = await sb.auth.signInWithOtp({ email });
                if (error) { alert('Sign-in failed, check console.'); console.error(error); return; }
                alert('Check your email for a magic link to sign in.');
            });
        });

        const form = document.getElementById('reviewForm');
        const reviewsList = document.getElementById('reviewsList');
        const avgRatingEl = document.getElementById('avgRating');
        const avgStarsEl = document.getElementById('avgStars');
        const countEl = document.getElementById('count');

        function renderStars(n) {
            const fullCount = Math.floor(n);
            const half = Math.abs(n - fullCount - 0.5) < 0.001;
            const emptyCount = 5 - fullCount - (half ? 1 : 0);
            return 'â˜…'.repeat(fullCount) + (half ? 'Â½' : '') + 'â˜†'.repeat(emptyCount);
        }

        async function loadReviewsFromSupabase() {
            // select id so we can attach replies and votes
            // choose whether to request owner depending on schema
            let res;
            try {
                if (ownerColumnExists) {
                    res = await sb.from('reviews').select('id,name,comment,rating,created_at,owner,mason_reply').order('created_at', { ascending: true });
                } else {
                    res = await sb.from('reviews').select('id,name,comment,rating,created_at,mason_reply').order('created_at', { ascending: true });
                }
            } catch (e) {
                console.error('loadReviews failed', e);
                const dbg = document.getElementById('reviewsDebug'); if (dbg) { dbg.style.display = 'block'; dbg.textContent = 'Error loading reviews: ' + (e.message || JSON.stringify(e)); }
                return [];
            }
            if (res.error) {
                console.error('loadReviews failed', res.error);
                const dbg = document.getElementById('reviewsDebug'); if (dbg) { dbg.style.display = 'block'; dbg.textContent = 'Error loading reviews: ' + (res.error.message || JSON.stringify(res.error)); }
                return [];
            }
            console.debug('loadReviews result', res.data && res.data.length ? `${res.data.length} rows` : '0 rows');
            return (res.data || []).map(r => {
                const t = r.created_at ? Date.parse(r.created_at) : Date.now();
                return { id: r.id, name: r.name, comment: r.comment, rating: Number(r.rating), t, owner: ownerColumnExists ? (r.owner || null) : null, mason_reply: r.mason_reply || '' };
            });
        }

        

        // load replies for a review
        async function loadReplies(reviewId) {
            const { data, error } = await sb.from('review_replies').select('id,name,message,created_at,owner').eq('review_id', reviewId).order('created_at', { ascending: true });
            if (error) { console.warn('loadReplies', error); return []; }
            return data || [];
        }

        async function insertReplyToSupabase(reviewId, reply) {
            const payload = { review_id: reviewId, name: reply.name, message: reply.message };
            if (currentUser && currentUser.id) payload.owner = currentUser.id;
            const { error } = await sb.from('review_replies').insert([payload]);
            return error;
        }

        // load vote counts for a set of review ids
        async function loadVotesMap(reviewIds) {
            if (!reviewIds || reviewIds.length === 0) return {};
            const { data, error } = await sb.from('review_votes').select('review_id,vote').in('review_id', reviewIds);
            if (error) { console.warn('loadVotesMap', error); return {}; }
            const map = {};
            (data || []).forEach(v => { map[v.review_id] = (map[v.review_id] || 0) + Number(v.vote); });
            return map;
        }

        async function voteReview(reviewId, voter, vote) {
            // vote: 1 or -1
            const payload = { review_id: reviewId, voter: voter || null, vote: vote };
            if (currentUser && currentUser.id) payload.owner = currentUser.id;
            const { error } = await sb.from('review_votes').insert([payload]);
            return error;
        }

        async function insertReviewToSupabase(review) {
            // avoid sending a millisecond timestamp that can overflow integer DB columns;
            // rely on the table's created_at column instead and only insert the fields we need
            const payload = { name: review.name, comment: review.comment, rating: review.rating };
            if (currentUser && currentUser.id) payload.owner = currentUser.id;
            const { error } = await sb.from('reviews').insert([payload]);
            return error;
        }

        async function render() {
            const reviews = await loadReviewsFromSupabase();
            reviewsList.innerHTML = '';
            await refreshAdminSet();
            if (reviews.length === 0) {
                const el = document.createElement('div');
                el.className = 'empty';
                el.textContent = 'No reviews yet. Be the first to leave feedback.';
                reviewsList.appendChild(el);
                avgRatingEl.textContent = '0.0';
                avgStarsEl.textContent = 'â˜†â˜†â˜†â˜†â˜†';
                countEl.textContent = '(0 reviews)';
                return;
            }
            const avg = reviews.reduce((s, r) => s + r.rating, 0) / reviews.length;
            avgRatingEl.textContent = avg.toFixed(1);
            avgStarsEl.textContent = renderStars(avg);
            countEl.textContent = `(${reviews.length} review${reviews.length>1?'s':''})`;

            // pre-load votes for all reviews
            const ids = reviews.map(r => r.id);
            const votesMap = await loadVotesMap(ids);

            reviews.slice().reverse().forEach(r => {
                const card = document.createElement('article');
                card.className = 'card';
                const meta = document.createElement('div');
                meta.className = 'meta';
                const name = document.createElement('strong');
                name.textContent = r.name;
                const stars = document.createElement('span');
                stars.className = 'stars';
                stars.textContent = renderStars(r.rating);
                const time = document.createElement('time');
                time.style.marginLeft = 'auto';
                time.style.color = 'var(--muted)';
                time.style.fontSize = '0.85rem';
                time.textContent = new Date(r.t).toLocaleString();
                meta.appendChild(name);
                // if signed-in user is an admin and is the owner of this review, show ADMIN badge
                if (r.owner && adminIdSet.has(r.owner)) {
                    const ab = document.createElement('span');
                    ab.className = 'admin-badge';
                    ab.textContent = 'ADMIN';
                    meta.appendChild(ab);
                }
                meta.appendChild(stars);
                meta.appendChild(time);

                const text = document.createElement('p');
                text.style.margin = '8px 0 0';
                text.textContent = r.comment;

                const masonReply = document.createElement('div');
                masonReply.className = 'mason-reply';
                masonReply.style.display = r.mason_reply ? 'block' : 'none';
                masonReply.innerHTML = `<div class="mason-reply-head"><strong>Mason</strong> <span class="admin-badge">ADMIN</span></div><div class="mason-reply-body">${r.mason_reply}</div>`;

                // votes UI
                const votesWrap = document.createElement('div');
                votesWrap.style.marginTop = '8px';
                const score = document.createElement('span');
                let vcount = votesMap[r.id] || 0;
                score.textContent = `Score: ${vcount}`;
                score.style.marginRight = '12px';
                const up = document.createElement('button'); up.textContent = 'ðŸ‘'; up.style.marginRight = '6px';
                const down = document.createElement('button'); down.textContent = 'ðŸ‘Ž';
                up.addEventListener('click', async () => {
                    up.disabled = true; down.disabled = true;
                    const voter = prompt('Your name (optional):','Guest') || null;
                    const err = await voteReview(r.id, voter, 1);
                    if (err) console.error('vote err', err);
                    else { vcount = (votesMap[r.id] = (votesMap[r.id]||0) + 1); score.textContent = `Score: ${votesMap[r.id]}`; }
                    up.disabled = false; down.disabled = false;
                });
                down.addEventListener('click', async () => {
                    up.disabled = true; down.disabled = true;
                    const voter = prompt('Your name (optional):','Guest') || null;
                    const err = await voteReview(r.id, voter, -1);
                    if (err) console.error('vote err', err);
                    else { vcount = (votesMap[r.id] = (votesMap[r.id]||0) - 1); score.textContent = `Score: ${votesMap[r.id]}`; }
                    up.disabled = false; down.disabled = false;
                });
                votesWrap.appendChild(score);
                votesWrap.appendChild(up);
                votesWrap.appendChild(down);

                // replies container
                const repliesContainer = document.createElement('div');
                repliesContainer.style.marginTop = '10px';
                repliesContainer.className = 'replies-container';

                // reply form (collapsed by default)
                const replyForm = document.createElement('div');
                replyForm.style.marginTop = '8px';
                const replyBtn = document.createElement('button'); replyBtn.textContent = 'Reply';
                const replyFields = document.createElement('div');
                replyFields.style.display = 'none';
                replyFields.innerHTML = `<input placeholder="Your name" class="reply-name" style="margin-bottom:6px;width:100%;padding:8px;border:1px solid #ddd;border-radius:6px"><textarea placeholder="Write a reply..." class="reply-message" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:6px;margin-top:6px"></textarea><div style="text-align:right;margin-top:6px"><button class="reply-submit">Send</button></div>`;
                replyBtn.addEventListener('click', () => { 
                    // prefill reply name if admin signed in
                    const nameField = replyFields.querySelector('.reply-name');
                    if (currentUserIsAdmin && currentAdminDisplayName && nameField) nameField.value = currentAdminDisplayName;
                    replyFields.style.display = replyFields.style.display === 'none' ? 'block' : 'none'; 
                });
                replyForm.appendChild(replyBtn);
                replyForm.appendChild(replyFields);

                // wire reply submit
                replyFields.querySelector('.reply-submit').addEventListener('click', async (ev) => {
                    const rname = replyFields.querySelector('.reply-name').value.trim() || 'Guest';
                    const rmsg = replyFields.querySelector('.reply-message').value.trim();
                    if (!rmsg) return;
                    const err = await insertReplyToSupabase(r.id, { name: rname, message: rmsg });
                    if (err) { console.error('reply err', err); return; }
                    replyFields.querySelector('.reply-name').value = '';
                    replyFields.querySelector('.reply-message').value = '';
                    // reload replies
                    const items = await loadReplies(r.id);
                    renderReplies(items, repliesContainer);
                });

                function renderReplies(items, container) {
                    container.innerHTML = '';
                    if (!items || items.length === 0) return;
                    items.forEach(it => {
                        const el = document.createElement('div');
                        el.style.padding = '8px';
                        el.style.borderTop = '1px solid #eef2ff';
                        const nameHtml = `<strong>${it.name||'Guest'}</strong>${(it.owner && adminIdSet.has(it.owner)) ? ' <span class="admin-badge">ADMIN</span>' : ''}`;
                        el.innerHTML = `${nameHtml} <span style="color:var(--muted);font-size:0.9rem;margin-left:8px">${new Date(it.created_at).toLocaleString()}</span><div style="margin-top:6px">${it.message}</div>`;
                        container.appendChild(el);
                    });
                }

                // initial load of replies
                (async () => { const items = await loadReplies(r.id); renderReplies(items, repliesContainer); })();

                card.appendChild(meta);
                card.appendChild(text);
                card.appendChild(masonReply);
                card.appendChild(votesWrap);
                card.appendChild(repliesContainer);
                card.appendChild(replyForm);
                reviewsList.appendChild(card);
            });
        }

        form.addEventListener('submit', async e => {
            e.preventDefault();
            const name = document.getElementById('name').value.trim();
            const comment = document.getElementById('comment').value.trim();
            const rating = parseFloat(document.getElementById('rating').value);
            if (!name || !comment || isNaN(rating)) return;

            // don't send a millisecond timestamp to the DB (may overflow integer columns);
            // rely on created_at and insert only the necessary fields
            const review = { name, comment, rating };
            const err = await insertReviewToSupabase(review);
            if (err) {
                console.error('Insert error', err);
                return;
            }
            form.reset();
            await render();
        });

        

        // initial render
        render();

        // real-time updates
        try {
            sb.channel('public:reviews')
              .on('postgres_changes', { event: '*', schema: 'public', table: 'reviews' }, () => {
                  render();
              })
              .subscribe();
        } catch (e) { console.warn('reviews realtime failed', e); }
    </script>
</body>
</html>
